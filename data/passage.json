{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1647164774598889473",
        "title": "coderwhy的vue3课程笔记02-组合式API",
        "description": "组合式API",
        "content": "## 组合式API\n\n#### 产生背景\n\n- 在Vue2中，我们编写组件的方式是Options API ：也就是在对应的属性中编写对应的功能模块；例如：`data`定义数据, `methiods`中定义方法，`computed`中定义计算属性；`watch`中监听属性的变化；也包括生命周期钩子\n- 但是这种代码有弊端：当我们实现某一个功能；这个功能对应的代码逻辑会被拆分到各个属性中；当我们组件变大变复杂后，同一个功能的逻辑就会被拆分的很分散；尤其是在后期维护上，对用对于一个没有编写过这个代码的人来说；\n- 所以我们就想要把同一个逻辑关注点相关的代码收集在一起；这也就是`Composition API`要帮我们做的事情，也有人把Vue Composition API 称为VCA\n\n#### Composition API是什么？\n\n- 如果我们想要使用Ccomposition API 那么我们首先需要一个环境（实际使用它编写代码的地方），在Vue组件中，这个位置就是`setup`函数\n- `setup`其实就是组件的另外一个选项：只不过这个选项强大到可以我们用它来替代之前所编写的大部分其他选项；如`methods`、`computed`、`watch`、`data`、生命周期等等\n\n#### setup函数的参数\n\n###### 他的第一个参数： `props`\n\n`props`非常好理解，它其实就父组件传递过来的属性会被放到`props`对象，如果我们在setup中需要使用，我们可以直接通过props参数获取\n\n- 对于定义props类型。和之前一样\n- 在template中依然可以正常使用props中属性，如message\n- 注意：我们在setup函数中想要使用props，我们不可用通过this去获取 因为props有直接作为参数传递到setup函数中，所有我们可以直接通过参数获取使用\n\n###### 另外一个参数：`context`\n\n我们也称之为是一个`SetupContext`, 它里面包含三个属性：\n\n- `attrs`:所有的非prop的`attribute`\n- `slots`: 父组件传递过来的插槽（这个在以渲染函数返回时会有作用）\n- `emit` ： 当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可用通过this.$emit发出事件）\n\n#### setup函数的返回值\n\nsetup既然是一个函数，那么它也可以有返回值，它的返回值的作用有：\n\n1. 可以在模板`template`中被使用；\n2. 也就是说我们可以通过setup的返回值来代替data的选项\n3. 甚至是我们可以返回一个执行函数来代替在methods中定义的方法\n\n注意：我们定义的变量，然后再定义方法改变变量，是不能实现页面响应式刷新的，这是因为默认情况下，我们定义一个变量，Vue并不会跟踪它的变化来引起页面的响应式\n\n#### setup不可用使用this\n\n官方表示：this并没有指向当前组件实例，并且在setup被调用指点，`data`、`computed` 、 `methods`等都没有被解析，所以无法在setup中获取`this`\n\n##### Reactive API\n\n如果我们想要在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数：\n\n- 当我们使用reactive函数处理我们的数据之后，数据再次被使用就会进行依赖收集\n- 当数据发生变化，所有收集到的依赖都是进行对应的响应式操作\n- 事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程为响应式对象的\n\n#### Ref API\n\n因为reactive API对传入类型是有限制的，它要求我们必须传入的是一个对象或者数组类型：如果我们传入的是基本类型 vue会给出警告\n\n- vue3给我们提供了另外的API ref API ;ref 会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这也是ref名称的来源；它内部的值是在ref的value属性中被维护的\n- 注意：\n\n- - 在模板引入ref的值时，Vue会帮助我们进行解包操作，所以我们并不需要在模板中通过ref.value来使用ref（这里是将ref放入reactive属性中 如果不是放在reactive属性中就需要ref.value）\n  - 但是在setup函数内部，它依然是一个ref引用，我们使用需要使用ref.value\n\n\n\n#### readonly\n\n我们通过reactive或者ref可以获取到一个响应式的对象，但是在某些情况下，我们需要把这个数据传入到其他地方（组件）中使用，但是我们希望它不能被修改\n\nvue3为我们提供了readonly的方法，readonly会返回原生对象的只读代理（它是一个Proxy，这是一个proxy的set方法被劫持；不能对其进行修改）\n\n使用：\n\n在开发中我们通常会把readonly方法传入三个类型的参数：普通对象；reactive返回的对象；ref对象\n\n使用规则：\n\n- readonly返回的对象都是不允许修改的；\n- 但是经过readonly处理的原来的对象是允许被修改的；\n- 本质上就是readonly返回的对象的setter方法被劫持了\n\n#### Reactive判断的API\n\n- isProxy : 检查对象是否是由reactive或readonly创建的proxy\n- isReactive: 检查对象是否是由reactive创建的响应式代理；如果该代理是readonly建的，但包裹了由reacive创建的另一个代理，它也会返回true\n- isReadonly: 检查对象是否是由readonly创建的只读代理\n- toRaw: 返回reactive或readonly代理的原始对象（不建议保留对原始对象的持久引用）\n- shallowReactive：创建一个响应式代理，它跟踪其自身property的响应式，但不执行嵌套对象的深层响应式转换（深层还是原生对象）\n- shallowReadonly: 创建一个proxy，使其自身的property为只读，但不执行嵌套对象的深度只读转换（深沉还是可读，可写的）\n\n#### toRefs\n\n如果我们使用ES6的解构对象，对reactive返回的对象进行解构获取值，那么无论是修改解构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的\n\n那么我们如果想要解构出reactive返回的值而且还想要响应式，可以使用toRefs的函数，可以将reactive返回的对象中的属性都转成ref\n\n```vue\nconst state = reactive({\n  name: \"why\",\n  age: 18\n})\nconst {name, age} = toRefs(state)\n```\n\n这样 解构出来的name个age本身都是ref了， 这样的做法相当于已经在state.name和ref.value之间建立链接，任何一个修改都会引起另一个变化\n\n#### ref的其他API\n\n- unref ：如果我们想要获取一个ref引用中的value，那么也可以通过unref方法\n- 它接收一个值，如果参数是一个ref 则返回内部value，否则返回参数本身；它其实是一个语法糖，它做的事情就是`val = isRef(val) ? val.value : value` 其中isRef是判断一个值是否是一个ref对象\n- shallowRef ： 创建一个浅层的ref对象\n- triggerRef :  手动触发和shallowRef相关联的副作用\n\n#### customRef\n\n创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制：\n\n- 它需要一个工厂函数，该函数接受track和trigger函数作为参数 其中`track()`是告诉Vue这个value值是需要被跟踪的，trigger()是告诉vue去更新页面\n- 并且返回一个带有get和set的对象；\n\n```vue\n//useDebounceRef.js文件\n<script>\n  import { customRef } from 'vue';\n// 自定义ref 接收的value是一个字符串 \nexport default function(value, delay = 300) {\n  let timer = null;\n  return customRef((track, trigger) => {\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n        value = newValue;\n        trigger();\n        }, delay);\n      }\n    }\n  })\n}\n</script>\n// 示例\n<template>\n  <div>\n    <input v-model=\"message\"/>\n    <h2>{{message}}</h2>\n  </div>\n</template>\n<script>\n  import debounceRef from './hook/useDebounceRef';\n  export default {\n    setup() {\n      const message = debounceRef(\"Hello World\");\n      return {message}}}\n</script>\n<style scoped>\n</style>\n```\n\n#### computed\n\n###### 是什么？\n\n计算属性：当我们的某些属性是依赖其他状态转化得到，我们就可以使用计算属性来实现\n\n###### 怎么实现？\n\n在组合式API，我们使用`computed`选项来完成的\n\n```vue\nconst firstName = ref(\"Kobe\");\nconst lastName = ref(\"Bryant\");\n// 1.用法一: 传入一个getter函数\n// computed的返回值是一个ref对象\nconst fullName = computed(() => firstName.value + \" \" + lastName.value);\n// 2.用法二: 传入一个对象, 对象包含getter/setter，返回一个可读写的ref对象\nconst fullName1 = computed({\n  get: () => firstName.value + \" \" + lastName.value,\n  set(newValue) {\n    const names = newValue.split(\" \");\n    firstName.value = names[0];\n    lastName.value = names[1];\n  }\n```\n\n#### 侦听数据的变化\n\n###### 作用：\n\n我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行操作\n\n##### 1. watchEffect\n\n当侦听到某些响应式数据变化时，我们希望执行某些操作，\n\n- 首先，watchEffect传入的函数会被立即执行，并且在执行过程中收集依赖\n- 其次，只有当收集的依赖变化时，watchEffect传入的函数才会执行\n\n```vue\nconst name = ref(\"why\"); \nconst stop = watchEffect(() => {\n  console.log(\"name:\", name.value);\n});\n// 我们运行 stop();就会停止侦听\n```\n\n##### 2. watchEffect清除副作用\n\n在开发中，我们需要在侦听函数中执行网络请求，但是网络请求还没有到达的时候，我们停止了侦听，或者侦听器函数被再次执行了，为了解决这种问题，\n\n\n\n在我们给watchEffect传入的函数被回调时，我们可以从回调函数中，获取一个参数：`onInvalidate`，当副作用即将重新执行或者侦听器被停止时会执行该函数传入的回调函数，我们可以在传入的回调函数中，执行一些清除工作\n\n```vue\n<script>\nconst name = ref(\"why\");\nconst age = ref(18);\n\nconst stop = watchEffect((onInvalidate) => {\n  const timer = setTimeout(() => {\n    console.log(\"网络请求成功~\");\n  }, 2000)\n\n  // 根据name和age两个变量发送网络请求\n  onInvalidate(() => {\n    // 在这个函数中清除额外的副作用\n    // request.cancel()\n    clearTimeout(timer);\n    console.log(\"onInvalidate\");\n  })\n  console.log(\"name:\", name.value, \"age:\", age.value);\n});\n</script>\n```\n\n#### 使用ref获取元素或者组件\n\n##### 使用：\n\n我们定义一个ref对象，绑定到元素或者组件的ref的属性上即可；\n\n```vue\n<template>\n  <div>\n    <h2 ref=\"titleRef\">这里是一个title</h2>\n  </div>\n</template>\n<script>\n  setup(){\n    const titieRef = ref(null)\n    return {\n      titleRef\n    }\n  }\n</script>\n```\n\n#### watchEffect的执行时机\n\n##### 执行时机：\n\nsetup函数在执行时就会立即执行一次`watchEffect`的副作用函数，这个时候DOM并没有挂载，所有打印的一定是null，而当DOM挂载时，`watchEffect`的依赖会变化，副作用就会再次执行，打印出对应的内容\n\n##### 调整执行时机：\n\n如果我们不希望第一次的执行，我们需要改变副作用的执行时机，那么我们需要修改`watchEffect`的第二个参数，是一个对象，默认是`{flush: \"pre\"}`,我们可以修改成`{flush: \"post\"}这样就可以实现我们想要的效果`\n\n```vue\n<script>\n   const title = ref(null);\n      const demo = ref(null);\n    const stop=  watchEffect(() => {\n        console.log(title.value, demo.value);\n      }, {\n        flush: \"post\"\n      })\n    // stop()可以停止侦听\n</script> \n```\n\n#### watch的使用\n\n```vue\n<script>\n      setup() {\n      const info = reactive({name: \"why\", age: 18});\n\n      // 1.侦听watch时,传入一个getter函数\n      watch(() => info.name, (newValue, oldValue) => {\n        console.log(\"newValue:\", newValue, \"oldValue:\", oldValue);\n      })\n\n      // 2.传入一个可响应式对象: reactive对象/ref对象\n      // 情况一: reactive对象获取到的newValue和oldValue本身都是reactive对象\n      watch(info, (newValue, oldValue) => {\n        console.log(\"newValue:\", newValue, \"oldValue:\", oldValue,'ssss');\n      })\n      // 如果希望newValue和oldValue是一个普通的对象\n      watch(() => {\n        return {...info}\n      }, (newValue, oldValue) => {\n        console.log(\"newValue:\", newValue, \"oldValue:\", oldValue, \"oldValue:\");\n      })\n      // 情况二: ref对象获取newValue和oldValue是value值的本身\n      // const name = ref(\"why\");\n      // watch(name, (newValue, oldValue) => {\n      //   console.log(\"newValue:\", newValue, \"oldValue:\", oldValue);\n      // })\n\n      const changeData = () => {\n        info.name = \"kobe\";\n      }\n      \n       // 1.定义可响应式的对象\n      const info = reactive({name: \"why\", age: 18});\n      const name = ref(\"why\");\n\n      // 2.侦听器watch\n      watch([() => ({...info}), name], ([newInfo, newName], [oldInfo, oldName]) => {\n        console.log(newInfo, newName, oldInfo, oldName);\n      }，{\n        deep: true,\n        immediate: true\n      })\n      return {\n        changeData,\n        info\n      }\n    }\n</script>\n```\n\n从上面代码中，可以知道watch的第一个参数，可以是 回调函数（返回值是我们监听的对象），可以是一个值，可以是一个数组，第二个参数是一个回调函数，当依赖发生变化它会执行，第三个参数是一个对象，可以修改它的一些执行时机\n\n##### 它与watchEffect的区别\n\n1. 它是懒执行副作用，即只有当侦听的源发生变化它才会执行回调函数；\n2. 更加明确的说明说明状态应该触发侦听器的重新运行；\n3. 可以访问侦听前后的值\n\n#### JSX的babel配置\n\n如果我们能在项目中使用jsx，那么我们需要添加对jsx的支持；jsx我们通常会通过babel进行转换（react也是）\n\n对于vue 我们只需要在Babel中配置对应的插件既可\n\n```bash\nnpm install @vue/babel-plugin-jsx -D\n//在babel.config.js文件配置插件\nmodule.exports = {\n  presets:[\n    '@vue/cli-plugin-bable/preset'\n  ],\n  plugins: [\n    \"@vue/babel-plugin-jsx\"\n  ]\n}\n```\n\n#### 组合式API中的Provide和Inject\n\n```vue\n<script>\n  // 父组件中，我们通过Provide来创建数据\n  import { provide } from 'vue';\n   const name = ref(\"coderwhy\");\n   let counter = ref(100);\n   provide(\"name\", readonly(name));\n   provide(\"counter\", readonly(counter));\n  // 子组件通过Inject来获取父组件的值\n  import { inject } from 'vue';\n  const name = inject(\"name\");\n  const counter = inject(\"counter\");\n</script>\n```\n\n##### 注意：\n\n1. 我们可以在provide值时使用ref和reactive来增加provide值和inject值之间的响应性, 这样父组件修改保存到`provide`的值，子组件也会接收到变化\n2. `provide`可以传入两个参数:\n\n1. 1. name：提供的属性名称\n   2. value：提供对应的属性值\n\n1. inject可以传入两个参数：\n\n1. 1. 要inject的property的name\n   2. 默认值\n\n1. 我们需要修改可响应的值，那么我们最好在数据提供处来进行修改，并把修改写成一个方法，并暴露出去给子组件使用",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 17,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-15T09:07:39.000+00:00",
        "updateTime": "2023-04-16T07:06:50.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-14T02:39:50.000+00:00"
        },
        "tags": [
          "文章",
          "Vue",
          "前端"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1646892100974858241",
        "title": "coderwhy的vue3课程笔记01-基础语法",
        "description": "vue3基础语法",
        "content": "## coderwhy的vue3课程笔记01-基础语法\n\n#### v-once：用于指定元素或者组件只渲染一次\n\n当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；用于**性能优化**\n\n#### v-bind: 动态绑定一个或多个`attribute`(ps:属性), 或者向另一个组件传递props值\n\nv-bind的语法糖是 `:`\n\n```vue\n<img v-bind:src='src' alt='' />\n<img :src='src' />\n// 其他写法\n<div :[name]=\"value\">哈哈哈</div>\ndata() {\n   return {\n     name: \"cba\",\n     value: \"kobe\"\n   }\n }\n<div :=\"info\">哈哈哈哈</div> \ninfo: {\n   name: \"why\",\n   age: 18,\n   height: 1.88\n }\n```\n\n#### v-on ：绑定事件\n\n前面我们绑定了元素的`内容和属性`,在前端开发中另外一个非常重要的特性就是`交互` , 所以vue是使用`v-on`来实现事件监听\n\n###### v-on的使用：\n\n1. 缩写 :·`@`\n2.  参数：`event`\n3. 修饰符：\n\n1. 1. `stop`- 调用 `event.stopPropagation()`\n   2. `.prevent` - 调用 `event.preventDefault()`。\n   3. `.capture`－添加事件侦听器时使用`capture`模式。\n   4. `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。`.{keyAlias} `- 仅当事件是从特定键触发时才触发回调。\n   5. `.once` - :只触发一次回调。\n   6. `.left` - 只当点击鼠标左键时触发。\n   7. `.right` - 只当点击鼠标右键时触发。\n   8. `.middle` - 只当点击鼠标中键时触发。\n   9. `.passive `-` { passive: true } `模式添加侦听器☐ 用法：绑定事件监听\n\n```vue\n<button v-on:click=\"btn1Click($event,'syh')\">按钮1</button>\n<div class=\"area\" v-on:mousemove=\"mouseMove\">div</div>\n<div class=\"area\" @=\"{click: btn1Click, mousemove: mouseMove}\"></div>\nmethods: {\n   btn1Click() {\n     console.log(\"按钮1发生了点击\");\n   },\n   mouseMove() {\n     console.log(\"鼠标移动\");\n   }\n }\n```\n\n#### `v-show`和 `v-if`的区别\n\n###### 首先\n\n1. `v-show`是不支持`template`\n2. `v-show`不可用和`v-else`一起使用；\n\n###### 其次，本质的区别：\n\n1. `v-show`元素无论是否需要显示。它的Dom实际上都存在\n2. `v-if`当条件为`false`的时候；其对应的原生压根不会渲染到dom中\n\n###### 最后；使用场景\n\n1. 如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用`v-show`否则就使用`v-if`\n\n###### 注意： \n\n因为`v-if`是一个指令，所有必须将其添加到一个元素上；但是我们切换的是多个元素呢？这个时候我们就可以使用`template`\n\n```vue\n<template v-if=\"isShowHa\">\n   <h2>哈哈哈哈</h2>\n   <h2>哈哈哈哈</h2>\n   <h2>哈哈哈哈</h2>\n </template>\n```\n\n#### `v-for`列表渲染\n\n###### 基本使用\n\n基本格式是： `item in arr`\n\n`item`是我们给每项元素起的一个别名， `arr`是数组名称\n\n当我们遍历一个数组的时候有时候会需要拿到`数组的索引`\n\n我们可以使用格式：`(item, index) in arr`;\n\n```vue\n  <template id=\"my-app\">\n    <h2>电影列表</h2>\n    <ul>\n      <!-- 遍历数组 -->\n      <li v-for=\"(movie, index) in movies\">{{index+1}}.{{movie}}</li>\n    </ul>\n    <h2>个人信息</h2>\n    <ul>\n      <!-- 遍历对象 -->\n      <li v-for=\"(value, key, index) in info\">{{value}}-{{key}}-{{index}}</li>\n    </ul>\n    <h2>遍历数字</h2>\n    <ul>\n      <li v-for=\"(num, index) in 10\">{{num}}-{{index}}</li>\n    </ul>\n  </template>\n\n const App = {\n      template: '#my-app',\n      data() {\n        return {\n          movies: [\n            \"星际穿越\",\n            \"盗梦空间\",\n            \"大话西游\",\n            \"教父\",\n            \"少年派\"\n          ],\n          info: {\n            name: \"why\",\n            age: 18,\n            height: 1.88\n          }\n        }\n      }\n    }\n```\n\n![img](D:\\snail_run\\documets\\assets\\vue\\vue_init)\n\n### 注意：\n\n当我们需要循环(`v-for`)包括多个元素或者判断包括多个元素（`v-if`）的时候，我们可以使用`templete`来包裹这多个元素。\n\n#### `vue`对原生数组的封装（使用其方法会触发ui变化）\n\n1. `push()``pop()` `shift()` `unshift()``splice()` `sort()` `reverse()` 上面的是直接改变原生数组\n2. `filter()` `concat()` `slice()` 不会改变原数组\n\n### Vue3的Options-API\n\n在实际开发中，我们会遇到一些情况，比如我们可能需要**对数据进行一些转化**后再显示，或将**多个数据结合起来**进行显示；如果把这些逻辑直接写在`template`中，这样就会使得UI里放逻辑，就违背了`vue`设计的愿景, 这个时候`compute`计算属性就产生了\n\n#### computed 计算属性\n\n对于任何响应式数据的复杂逻辑，都应该放在使用`computed`\n\n`计算属性`将被混入到组件实例中。所有getter和setter的上下文自动绑定为组件实例\n\n###### 使用方法：\n\n```vue\n  data() {\n        return {\n          firstName: \"Kobe\",\n          lastName: \"Bryant\",\n          score: 80,\n          message: \"Hello World\"\n        }\n      },\n      computed: {\n        // 定义了一个计算属性叫fullname\n        fullName() {\n          return this.firstName + \" \" + this.lastName;\n        },\n        result() {\n          return this.score >= 60 ? \"及格\": \"不及格\";\n        },\n        reverseMessage() {\n          return this.message.split(\" \").reverse().join(\" \");\n        }\n      }\n```\n\n\n\n#### watch 监听器\n\n我理解为当data变化后watch定义的函数来执行data变化产生的副作用\n\n###### 使用：\n\n```vue\ndata() {\n  return {\n    // 侦听question的变化时, 去进行一些逻辑的处理(JavaScript, 网络请求)\n    question: \"Hello World\",\n    anwser: \"\"\n  }\n},\nwatch: {\n  // question侦听的data中的属性的名称\n  // newValue变化后的新值\n  // oldValue变化前的旧值\n  question: function(newValue, oldValue) {\n    console.log(\"新值: \", newValue, \"旧值\", oldValue);\n    this.queryAnswer();\n  }\n},\n```\n\n###### 监听器`watch`的配置选项：\n\n1. `watch`只是在侦听info的引用变化，对于内部属性的变化说不会做出相应的，我们可以使用`选项deep`进行更深层的侦听；\n2. 另外一个属性，是希望一开始就会立即执行一次：\n\n1. 1. 这个时候我们使用`immediate选项`\n   2. 这个时候无论后面的数据是否有变化，侦听的函数都会有限执行一次；\n\n```vue\n watch: {\n        // 默认情况下我们的侦听器只会针对监听的数据本身的改变(内部发生的改变是不能侦听)\n        // info(newInfo, oldInfo) {\n        //   console.log(\"newValue:\", newInfo, \"oldValue:\", oldInfo);\n        // }\n\n        // 深度侦听/立即执行(一定会执行一次)\n        info: {\n          handler: function(newInfo, oldInfo) {\n            console.log(\"newValue:\", newInfo.nba.name, \"oldValue:\", oldInfo.nba.name);\n          },\n          deep: true, // 深度侦听\n          // immediate: true // 立即执行\n        },\n\t\t\t\t\t//也可以监听info的属性\n\t\t\t\t'info.name': function(){\n          console.log(this.info.name, 'info.name');\n        }\n      },\n```\n\n###### `watch`的其他使用方法\n\n```vue\n const unwatch = this.$watch(\"info\", function(newInfo, oldInfo) {\n          console.log(newInfo, oldInfo);\n        }, {\n          deep: true,\n          immediate: true\n        })\n```\n\n#### `v-model`绑定表单数据\n\n1. `v-model`指令可以在表单 `input`，`textarea`以及`select`元素上创建双向数据绑定，\n2. 它会根据控件类型自动选择正确的方法来更新元素\n3. `v-model`本质上是语法糖，它负责监听用户的输入事件来更新数据，并在极端场景下进行一些特殊处理；\n\n###### `v-model`的原理 ：两个操作\n\n- `v-bind`绑定`value`属性的值；\n- `v-on`绑定`input`事件监听到函数中，函数会获取最新的值赋值到绑定的属性中\n\n###### 具体使用\n\n```vue\n//绑定textarea article是一个字符串\n<textarea v-model=\"article\"> </textarea>\n\n//绑定checkbox -单个勾选框 isAgree是一个布尔值\n<input id='agreement' type=\"checkbox\" v-model=\"isAgree\" />\n//绑定checkbox -多个复选框 hobbies是一个数组\n<label for=\"basketball\">\n  <input id=\"basketball\" type=\"checkbox\" v-model=\"hobbies\" value=\"basketball\"> 篮球\n</label>\n<label for=\"football\">\n  <input id=\"football\" type=\"checkbox\" v-model=\"hobbies\" value=\"football\"> 足球\n</label>\n<label for=\"tennis\">\n  <input id=\"tennis\" type=\"checkbox\" v-model=\"hobbies\" value=\"tennis\"> 网球\n</label>\n\n//radio gender是一个字符串 是input的value\n<label for=\"male\">\n  <input id=\"male\" type=\"radio\" v-model=\"gender\" value=\"male\">男\n</label>\n<label for=\"female\">\n  <input id=\"female\" type=\"radio\" v-model=\"gender\" value=\"female\">女\n</label>\n\n// 绑定select fruit是一个字符串的时候就是单选，如果是一个数组就是多选\n<select v-model=\"fruit\" multiple size=\"2\">\n  <option value=\"apple\">苹果</option>\n  <option value=\"orange\">橘子</option>\n  <option value=\"banana\">香蕉</option>\n</select>\n```\n\n#### v-model 的修饰符\n\n###### 1. -lazy\n\n默认情况下，v-model在进行双向绑定时，绑定的是`input事件`那么每次输入后就会将最新的值和绑定的属性进行同步，如果我们加上`lazy`符号那么绑定的事件切换为`change`事件，只有在提交时候才会触发\n\n```vue\n<template id=\"my-app\">\n\t<input type =\"text\" v-model.lazy = \"message\">\n\t<h2>{{ message }}</h2>\n</template>\n```\n\n###### 2. - number\n\n如果我们希望将输入转化为数字，那么就使用`.number`在可以转化的情况下，会将其转化为`number`类型\n\n```vue\n<input type='text' v-model.number = 'message' />\n```\n\n###### 3. -trim\n\n如果要自动过滤掉用户输入的空白字符，可以给`v-model`后面在上`.trim`修饰符\n\n#### 组件化开发\n\n###### 定义一个全局组件\n\n```vue\n// 使用app注册一个全局组件app.component()\n// 全局组件: 意味着注册的这个组件可以在任何的组件模板中使用\n<script>\napp.component(\"component-a\", {\n  template: \"#component-a\",\n  data() {\n    return {\n      title: \"我是标题\",\n      desc: \"我是内容, 哈哈哈哈哈\",\n    };\n  },\n  methods: {\n    btnClick() {\n      console.log(\"按钮的点击\");\n    },\n  },\n});\n</script>\n//模板\n<template id=\"component-a\">\n   <h2>{{title}}</h2>\n   <p>{{desc}}</p>\n   <button @click=\"btnClick\">按钮点击</button>\n</template>\n// 使用\n<component-a></component-a>\n```\n\n在通过`app.component`注册一个组价的时候，第一个参数是组件的名称，第二个是一个对象\n\n#### 注册局部组件\n\n全局组价是在程序一开始就会执行，全局组件就会被注册好， 但是有时候我们的某些组件在刚开始并没有被用到。并且全局组件`webpack`打包时候也是对其打包，用户在下载对应JavaScript包时候也会增加包的大小\n\n所以我们在开发中使用组件应采用**局部注册**：\n\n- 局部注册是在我们需要使用到的组件中，通过`component`属性选择来进行注册，类似于`computed`,`methods`\n- 该`components`选项对应的是一个对象，对象中的键值对是 **组件的名称：组件对象**\n\n```vue\n  <template id=\"component-a\">\n    <h2>我是组件A</h2>\n    <p>我是内容, 哈哈哈哈</p>\n  </template>\n  <script>\n    const ComponentA = {\n      template: \"#component-a\"\n    }\n    const App = {\n      template: '#my-app',\n      components: {\n        ComponentA: ComponentA\n      },\n    }\n    const app = Vue.createApp(App);\n    app.mount('#app');\n  </script>\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 16,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-14T15:04:09.000+00:00",
        "updateTime": "2023-04-16T00:31:10.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-14T02:39:50.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "框架",
          "Vue"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1646875592437583873",
        "title": "解决win10中VMware中初次部署虚拟器出现的问题",
        "description": null,
        "content": "\n# 一，电脑蓝屏问题\n\n        打开控制面板>卸载程序>打开或关闭 Windows 功能，勾选虚拟机平台\n\n![image.png](https://pic.code-nav.cn/post_picture/1621702672539205634/hgGLsTpb-image.png)\n \n\n \n\n# 二，Device Guard/Credential Guard不兼容问题\n\n        网上教程让关闭 Hyper-V已经在本地组策略编辑器中禁用Device Guard。但是家庭版win10没有这个选项，所以查了很多资料，以及csdn，找到下面办法\n\n## 解决办法一：\n\n        安装VMware16 版本，但是很多课程用的都是旧版如果要使用旧版，如果要使用旧版，教程如下\n\n## 解决办法二：\n\n        第一步：cmd命令输入regedit进入注册表，找到HKEY_LOCAL_MACHINE \\ System \\ CurrentControlSet \\ Control \\ DeviceGuard，将默认的值改为0\n\n![image.png](https://pic.code-nav.cn/post_picture/1621702672539205634/g0bJBn0F-image.png)\n \n\n        第二步：【win+x】选择 Windows Powershell （管理员）（A） 执行 bcdedit /set hypervisorlaunchtype off\n\n        第三步：重启电脑。\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 6,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1621702672539205634",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-14T13:58:33.000+00:00",
        "updateTime": "2023-04-16T03:59:18.000+00:00",
        "user": {
          "id": "1621702672539205634",
          "planetCode": "6191",
          "userName": "尹先生",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/TnCApzfAP8eibkFiaydLibUcmwRoALs9NcR2NtwrVxcuzFkMJodmvOWgdsiatRPhLjRicKkoq1XR08blibQvEEK8oJTg/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": "中北大学",
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-03-13T12:38:07.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-04T02:50:21.000+00:00",
          "updateTime": "2023-04-14T13:58:58.000+00:00"
        },
        "tags": [
          "文章",
          "Linux",
          "Java",
          "后端"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1646510042976931841",
        "title": "极简typescript入门",
        "description": "学习基础TypeScript知识",
        "content": "### 名词解释\n\n1. JS：JavaScript缩写\n2. TS：TypeScript缩写\n\n### 先说结论\n\n1. JS能做的事情，TS都能做，TS只是给JS增加了类型，地球人都知道JS是一门弱类型语言，非常灵活的同时，缺点也很明显，这意味着JS在运行时可能会出现类型错误。TS 提供了静态类型检查，有助于在编译阶段捕获类型错误。这可以防止运行时出现许多类型错误，并帮助开发人员编写更可靠的代码。\n\n### 如何学习？\n\n本文通过技术蛋老师的一个视频进行学习，具体学习步骤就是，通过做一个小项目，进行学习TS，理解为什么需要TS，JS的缺点，TS的优点等等！\n\n#### 项目介绍\n\n1. 一个很简单的表单增删功能操作，通过调用接口获取数据，然后渲染，\n2. 通过 TS 来约束变量，方法的行为，提高代码的可读性\n\n#### 步骤\n\n1. 全局安装 TS 命令： `npm i typescript -g` (mac不同)\n2. 创建一个TS文件，创建并打印一个变量\n3. 在终端输入`tsc --init`，我们会多了一个文件`tsconfig.json`\n4. 打开`tsconfig.json`我们可以看到有一个`\"target\": \"es2016\"`\t，这里是将TS编译成JS遵循的标准\n5. 终端输入`tsc`，就会将我们的TS转为JS，对应的同名的JS文件\n6. 我们定义变量，可以在变量后使用冒号加一个类型值，就可以申明这个变量的类型了，举个例子：`let name: string = 'xiaoming'`这里如果给name赋值数值类型，编译的时候就会出错，而不是等到项目上线才会发现这个bug\n7. 我们可以使用`tsc -w`这里的w表示watch，每当文件保存的时候，就会自动的编译此文件为js文件\n8. 我们可以使用断言来解决一些问题，使用断言的方式非常简单，就是在值的末尾使用 as + 类型 即可，举个例子，`let dom = document.querySelector('button') as HTMLButtonElement`这样，我们就强制告诉dom是一个按钮类型的值\n9. 但是，断言的问题是被断言的值是有问题的，所有我们可以使用联合类型，来处理类型为多种情况的场景，使用方式非常简单，使用 | 来连接两个类型，举个例子：`let dom: HTMLButtonElement | null = document.querySelector('button')` \n10. 当我们要给一个对象申明类型的时候，并且这个类型还有很多地方需要复用，我们就可以使用 interface 接口了，使用非常简单，举个例子，`interface item {name: string; age: number; sex: 'boy' | 'girl'} `\n11. 我们可以在方法形参括号后加上一个类型，来指定返回类型，举个例子：`function aa(): void {}`\n12. 当我们并不知道Promise返回的具体内容的时候，我们可以用TS的泛型来表示，举个例子：`function getJSON<T>(url: string) {}`，这里的T表示的就是一个占位符，表示现在并不确定里面的类型\n13. 我们在使用 getJSON 方法的时候，可以去确定这个 T 的具体类型\n14. 我们通常定义一个数组类型里面的元素类型，是通过在 [] 前面加上一个具体的类型，例如： `let arr: string[] = ['1', '2']`,如果数组的元素是对象，那么我们就通过接口（interface）来定义\n15. 我们可以把error类型声明为 unkonwn 或者 Error\n\n```typescript\ntry {}\n\tcatch (err: Error | unkonwn) {\n    let message: string\n    if(err instanceof Error) {\n      message = err.message\n    }else {\n      message = String(err)\n  }\n    console.log(message, 'message')\n  }\n```\n\n1. 我们可以在 addEventListener后面加上 <'click'>来防止我们在后面监听事件值上出现拼写错误\n2. a 标签的 TS 类型为HTMLAnchorElement\n3. Event事件类型，有鼠标事件和键盘事件的区别\n\n### 小知识\n\n1. 绝大多数游览器识别不了TS，我们需要将TS编译成JS（看过极简Next.js的应该理解），然后给游览器识别运行\n2. tsc表示typescript compiler编译器的意思！init表示初始化\n3. 类型的首字母是小写，不是大写\n4. **使用TS，定义任何东西，要注明类型，调用任何东西要检查类型；**\n5. 类在接收接口（interface）的时候，不能使用变量声明的方式，也就是不能使用冒号（:），我们需要使用 implements 关键字，也就是实现的意思，举个例子：`class Cat implements item {}`\n6. 如果，你的接口里的有些键值对，有可能存在，也有可能不存在，我们可以在键的后面加上 ? 来告诉TS这个值可能不存在，举个例子 `interface item {name: string; age: number; like?: object}`\n\n### 参考\n\n1. 冴羽：https://ts.yayujs.com/\n2. 技术蛋老师：https://www.bilibili.com/video/BV12P411E79E",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/EDO0AJ9Z-wallpaper1.jpg",
        "language": null,
        "viewNum": 40,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-13T13:45:59.000+00:00",
        "updateTime": "2023-04-16T03:59:25.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-14T02:39:50.000+00:00"
        },
        "tags": [
          "文章",
          "前端"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1646189987475017729",
        "title": "极简Next.js指南，做一个自己的Next.js项目",
        "description": "Next.js强大的能力，它帮我完成了很多",
        "content": "## Next.js 学习\n\n\n\n官方文档地址：https://nextjs.org/\n\n\n\n**要有效地使用 Next.js，熟悉 JavaScript、React 和相关的 Web 开发概念是前提**\n\n\n\n### 1. 相关技术\n\n\n\n1. unpkg：https://unpkg.com/ \n\n1. 1. 一个快速的全球内容交付网络，适用于 npm 上的所有内容。使用它可以使用如下 URL 快速轻松地从任何包中加载任何文件：`unpkg.com/:package@:version/:file`\n   2. 一个CDN服务\n\n1. \n\n\n\n### 1. 快速创建一个Next.js应用\n\n\n\n#### 开发环境\n\n\n\n1. 安装Node.js环境到你的电脑 ；Node.js > 14.6.0 或者最近稳定版本（推荐使用[nvm](https://www.runoob.com/w3cnote/nvm-manager-node-versions.html)管理node版本）\n2. 一台生产力电脑\n3. 一个自己熟悉的编辑器，这里推荐`VSCode`或者`WebStorm`\n4. 跟着[官方教程](https://nextjs.org/docs/getting-started)， \n\n1. 1. init code：`pnpm create next-app`,有选择，选择你需要的能力即可\n   2. `npm run dev` 启动项目\n   3. \n\n\n\n### 2. Next.js如何工作\n\n\n\nNext.js 被一些世界上最大的公司使用，它使您能够通过扩展最新的 React 功能并集成强大的基于 Rust 的 JavaScript 工具来创建全栈 Web 应用程序以实现最快的构建。\n\n\n\n#### 1. 从开发环境到生产环境\n\n\n\n讲了，开发环境和生产环境的区别，Next.js对此做的优化\n\n\n\n##### 开发环境和生产环境区别\n\n\n\n- 在开发期间，您正在本地计算机上构建和运行应用程序。\n- 投入生产是让您的应用程序准备好部署和供用户使用的过程。\n\n\n\n##### Next.js针对其进行的优化\n\n\n\n- Next.js 会针对开发人员及其构建应用程序的经验进行优化。它具有旨在改善开发人员体验的功能，例如 **TypeScript** 和 **ESLint** 集成、**快速刷新**等。\n- 在生产阶段，Next.js 会针对最终用户以及他们使用该应用程序的体验进行优化。它旨在转换代码以使其具有*高性能*和*可访问性*。 由于每个环境都有不同的考虑因素和目标，因此将应用程序从开发转移到生产需要做很多事情。例如，应用程序代码需要**编译**、**捆绑**、**缩小**和**代码拆分**。\n\n\n\n##### Next.js真的可以让你的应用更加优秀\n\n\n\n因为 Next.js 有一个用 Rust 编写的编译器，一种低级编程语言，以及 SWC，一个可用于编译、缩小、捆绑等的平台。\n\n\n\n**接下来，我们具体看下Next.js为我们做了什么吧！**\n\n\n\n#### 2. 编译\n\n\n\n将我们写的代码，通过Next.js的魔法转化游览器能够解析的JavaScript代码，\n\n\n\n\n![compiler.png](https://pic.code-nav.cn/post_picture/1619930914211520514/vYaPRwe8-compiler.png)\n\n\n\n我们编写对开发人员更友好的语言编写代码，例如 JSX、TypeScript 和现代版本的 JavaScript。虽然这些语言提高了开发人员的效率和信心，但游览器却并不知道这是什么，我们需要将其编译为游览器理解的代码，\n\n\n\n##### 编译发生时机\n\n\n\n编译发生在您编辑代码的开发阶段，并且作为构建步骤的一部分，为您的应用程序做好生产准备。\uD83D\uDC8E\uD83D\uDC8E\n\n\n\n**编译是指获取一种语言的代码并将其输出为另一种语言或该语言的另一个版本的过程。**\n\n\n\n#### 3. 压缩\n\n\n\n我们项目源码可能包含代码运行所不需要的额外信息，例如注释、空格、缩进和多行（为了给开发者看）。生产环境打包好的代码是不需要的，因为它是给游览器理解，所有我们打包的时候需要移除这些额外信息\n\n\n\n\n![minifier.png](https://pic.code-nav.cn/post_picture/1619930914211520514/fKVomBMm-minifier.png)\n\n\n\n##### Next.js的压缩\n\n\n\n在 Next.js 中，JavaScript 和 CSS 文件会自动缩小以用于生产。\uD83D\uDC8E\uD83D\uDC8E\n\n\n\n**缩小是在不更改代码功能的情况下删除不必要的代码格式和注释的过程。目标是通过减小文件大小来提高应用程序的性能。**\n\n\n\n#### 4. 捆绑\n\n\n\n开发者通过拆解一个应用为：模块，组件，函数，方法，类，第三方库等等；通过导入导出实现功能，这同时创建了一个复杂的文件依赖关系网\n\n\n\n\n![bundler.png](https://pic.code-nav.cn/post_picture/1619930914211520514/N4fPI4Ck-bundler.png)\n\n\n\n为了减少用户访问网页时对文件的请求数量（请求文件数减少，页面加载就更快）。捆绑是解决网络依赖关系并将文件（或模块）合并（或“打包”）为浏览器优化捆绑包的过程\n\n\n\n**编译是将代码转换成浏览器可以解析的东西。捆绑正在解决您的应用程序依赖关系图并减少文件数量。**\n\n\n\n#### 5. 代码拆分\n\n\n\n代码拆分是将应用程序的包拆分为每个入口点所需的较小块的过程。目标是通过仅加载运行该页面所需的代码来缩短应用程序的初始加载时间。\n\n\n\n\n![cpdeSplittinng.png](https://pic.code-nav.cn/post_picture/1619930914211520514/2qqxKHVI-cpdeSplittinng.png)\n\n\n\n开发人员通常将他们的应用程序分成多个页面，可以从不同的 URL 访问这些页面。这些页面中的每一个都成为应用程序的唯一入口点。\n\n\n\nNext.js 内置了对代码拆分的支持。在构建步骤中，您的 pages/ 目录中的每个文件都将自动代码拆分为自己的 JavaScript 包。\n\n\n\n未来：\n\n\n\n- 页面之间共享的任何代码也被拆分到另一个包中，以避免在进一步导航时重新下载相同的代码。\n- 初始页面加载后，Next.js 可以开始预加载用户可能导航到的其他页面的代码。\n- **动态导入**是另一种手动拆分最初加载代码的方法。\n\n\n\n#### 6. 构建时和运行时\n\n\n\n两个非常重要的概念，帮助理解Next.js的底层工作原理\n\n\n\n**构建时间（或构建步骤）**是为生产应用程序代码准备的一系列步骤的名称。 当您构建应用程序时，Next.js 会将您的代码转换为生产优化文件，以准备部署到服务器并供用户使用。这些文件包括：\n\n\n\n- 静态生成页面的 HTML 文件\n- 用于在服务器上呈现页面的 JavaScript 代码\n- 使页面在客户端交互的 JavaScript 代码\n- CSS文件\n\n\n\n**运行时（或请求时间）**是指在构建和部署应用程序后，应用程序响应用户请求而运行的时间段。 接下来，让我们讨论一下本节中介绍的一些术语，例如客户端、服务器和渲染。\n\n\n\n#### 7. 客户端和服务端\n\n\n\n在 Web 应用程序的上下文中，\n\n\n\n-  客户端是指：用户设备上的浏览器，它向服务器发送应用程序代码请求。然后它将从服务器接收到的响应转换为用户可以与之交互的界面。 \n-  服务端：指数据中心的计算机，它存储您的应用程序代码，接收来自客户端的请求，进行一些计算，并发回适当的响应。 \n\n\n\n\n![clientServer.png](https://pic.code-nav.cn/post_picture/1619930914211520514/2WAwLrvf-clientServer.png)\n\n\n\n#### 7. 渲染\n\n\n\n将您在 React 中编写的代码转换为 UI 的 HTML 表示形式是不可避免的工作单元。这个过程称为渲染。\n\n\n\n渲染可以在服务器或客户端上进行。它可以在构建时提前发生，也可以在运行时针对每个请求发生。 使用 `Next.js`，可以使用三种类型的渲染方法：\n\n\n\n- 服务器端渲染\n- 静态站点生成\n- 客户端渲染\n\n\n\n##### 1. 预渲染\n\n\n\n**服务器端渲染**和**静态站点生成**也称为预渲染，因为 *外部数据的获取* 和  *React 组件到 HTML 的转换* 发生在结果发送到客户端之前。\n\n\n\n##### 2. 客户端渲染 VS预渲染\n\n\n\n在标准的 React 应用程序中，浏览器从服务器接收一个空的 `HTML shell` 以及构建 `UI 的 JavaScript 指令`。这称为客户端呈现，因为初始呈现工作发生在用户的设备上。\n\n\n\n\n![clientRender.png](https://pic.code-nav.cn/post_picture/1619930914211520514/Nq1rlBq1-clientRender.png)\n\n\n\n注意：您可以选择使用 React 的 useEffect() 或数据获取挂钩（如 useSWR）获取数据，从而为 Next.js 应用程序中的特定组件使用客户端呈现。\n\n\n\n相比之下，Next.js **默认预渲染每个页面**。预渲染意味着 HTML 是预先在服务器上生成的，而不是由用户设备上的 JavaScript 完成的。 实际上，这意味着对于完全由客户端呈现的应用程序，用户将在完成呈现工作时看到一个空白页面。与预渲染应用相比，用户将看到构建的 HTML，所以预渲染是对用户更加友好的渲染\n\n\n\n\n![preRender.png](https://pic.code-nav.cn/post_picture/1619930914211520514/B4muTLQx-preRender.png)\n\n\n\n接下来，具体看下两种预渲染：\n\n\n\n##### 3. 服务端渲染\n\n\n\n使用服务器端呈现，页面的 HTML 是在服务器上为每个请求生成的。然后将生成的 HTML、JSON 数据和使页面具有交互性的 JavaScript 指令发送到客户端。 在客户端，HTML 用于显示快速的非交互式页面，而 React 使用 JSON 数据和 JavaScript 指令使组件具有交互性（例如，将事件处理程序附加到按钮）。这个过程称为**水合作用**。 在 Next.js 中，您可以使用 `getServerSideProps` 选择服务器端呈现页面。\n\n\n\n注意：React 18 和 Next 12 引入了 React 服务端组件的 alpha 版本。服务器组件完全在服务器上呈现，不需要客户端 JavaScript 来呈现。此外，服务端组件允许开发人员在服务器上保留一些逻辑，并且只将该逻辑的结果发送给客户端。这减少了发送到客户端的包大小并提高了客户端渲染性能。了解有关 React 服务端的更多信息 组件在这里。\n\n\n\n##### 4. 静态站点生成\n\n\n\n使用静态站点生成，HTML 是在服务器上生成的。但与服务器端呈现不同的是，在运行时没有服务器。取而代之的是，在部署应用程序时，在构建时生成一次内容，HTML 存储在 CDN 中并为每个请求重新使用。 在Next.js 中，您可以选择使用 `getStaticProps` 静态生成页面。\n\n\n\n注意：您可以在构建网站后使用[增量静态重新生成来](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration)创建或更新静态页面。这意味着如果您的数据发生变化，您不必重建整个站点。\n\n\n\nNext.js 的美妙之处在于，您可以逐页为您的用例选择最合适的呈现方法，无论是静态站点生成、服务器端呈现还是客户端呈现。要详细了解哪种渲染方法适合您的特定用例，请参阅数据获取文档。 在下一节中，我们将讨论您的代码在部署后可以存储或运行的位置。\n\n\n\n#### 8. 网络\n\n\n\n了解应用程序代码的存储位置和部署到网络后的运行位置很有帮助。您可以将网络视为能够共享资源的链接计算机（或服务器）。\n\n\n\n对于 Next.js 应用程序，您的应用程序代码可以分发到原始服务器、内容分发网络 (CDNs) 和边缘。让我们看看它们分别是什么：\n\n\n\n##### 1. 原始服务器\n\n\n\n正如我们之前讨论的，服务器是指存储和运行应用程序代码原始版本的主计算机。 我们使用术语源来区分此服务器与应用程序代码可以分发到的其他地方，例如 CDN 服务器和边缘服务器。 当源服务器收到请求时，它会在发送响应之前进行一些计算。该计算工作的结果可以移动到 CDN（内容分发网络）。\n\n\n\n##### 2. 内容分发网络\n\n\n\nCDN 在全球多个位置存储静态内容（如 HTML 和图像文件），并放置在客户端和源服务器之间。当有新请求进来时，距离用户最近的 CDN 位置可以使用缓存的结果进行响应。\n\n\n\n\n![cdnServer.png](https://pic.code-nav.cn/post_picture/1619930914211520514/Gi6ZbX3p-cdnServer.png)\n\n\n\n这减少了源端的负载，因为不必在每个请求上都进行计算。它还使用户更快，因为响应来自地理位置更接近他们的位置。 在 Next.js 中，由于可以提前完成预渲染，因此 CDN 非常适合存储工作的静态结果——使内容交付更快。\n\n\n\n##### 3. 边缘\n\n\n\n边缘是网络边缘（或边缘）的广义概念，最接近用户。 CDN 可以被视为“边缘”的一部分，因为它们将静态内容存储在网络的边缘（边缘）。 与 CDN 类似，边缘服务器分布在世界各地的多个位置。但与存储静态内容的 CDN 不同，一些边缘服务器可以运行一小段代码。 这意味着缓存和代码执行都可以在靠近用户的边缘完成。 通过将一些传统上在客户端或服务器端完成的工作转移到边缘，您可以使您的应用程序性能更高，因为它减少了发送到客户端的代码量，并且用户的部分请求不必全部执行返回原始服务器的方式 - 从而减少延迟。请在此处查看带有 Next.js 的 Edge 示例。 在 Next.js 中，您可以使用中间件在边缘运行代码，很快就会使用 React 服务器组件。\n\n\n\n## END\n\n\n\n恭喜你看到了这里，Next.js的基础课程已经结束，现在 我们应该知道Next.js可以帮我们快速创建一个基于react的应用程序，它能够帮我们更加出色的完成打包，构建，让我们的应用程序更加快速的响应给用户，可以争对开发环境和部署环境进行特殊设置",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/84M5uqyB-Snipaste_2023-04-13_00-33-02.png",
        "language": null,
        "viewNum": 45,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-12T16:34:13.000+00:00",
        "updateTime": "2023-04-15T14:27:15.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-14T02:39:50.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "框架"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1645771979275423746",
        "title": "极简Next.js指南01，想学Next.js的看过来！",
        "description": "半小时学会基本的Next.js基础知识",
        "content": "#### 参考文档\n\n- https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#introduction\n- https://www.nextjs.cn/docs/getting-started\n- [https://nextjs.frontendx.cn/docs/#%E7%94%9F%E6%88%90%3Chead%3E](https://nextjs.frontendx.cn/docs/#生成)\n- https://github.com/vercel/next.js\n\n\n#### 优势（相比较其他框架）\n\n- 服务端渲染\n- seo友好\n\n#### next.js基本知识\n\n- 是一个react框架\n- 一个**零配置**，**单指令的react应用工具链 （？？？需要验证）**\n- 提供了一个通用的结构，使你能够轻松地建立一个前端的 React 应用程序，并透明地为你处理服务器端的渲染。**（？？？需要验证）**\n\n#### 主要功能\n\n- Hot Code Reloading（代码热加载）\n\nNext.js 在检测到保存到磁盘的任何变化时，会重新加载页面。\n\n- Automatic Routing（自动路由）\n\n任何 URL 都被映射到文件系统中，映射到放在 pages 文件夹中的文件，你不需要任何配置（当然你有自定义选项）\n\n- Single File Components（单文件组件）\n\n使用`styled-jsx`，完全集成在同一个团队中，为组件添加样式的范围是很简单的。\n\n- Server Rendering（服务器端渲染）\n\n你可以在服务器端渲染 React 组件，然后再将 HTML 发送到客户端。\n\n- Ecosystem Compatibility（生态系统的兼容性）\n\nNext.js 与 JavaScript、Node 和 React 生态系统的其他部分配合良好。\n\n- Automatic Code Splitting（自动代码拆分）\n\n渲染页面时，只需使用它们需要的库和 JavaScript，而无需其他。Next.js 不会生成一个包含所有应用程序代码的单一 JavaScript 文件，而是将应用程序自动分解为几个不同的资源。\n\n加载一个页面只加载该特定页面所需的 JavaScript。\n\nNext.js 通过分析导入的资源来做到这一点。\n\n例如，如果你只有一个页面导入了 Axios 库，那么这个特定的页面将在打包（bundle）的时候包含该库。\n\n这可以确保你的第一个页面加载速度尽可能快，而且只有未来的页面加载（如果它们将被触发）才会向客户端发送所需的 JavaScript。\n\n有一个值得注意的例外。如果经常使用的导入程序在网站页面中至少有一半被使用，它们就会被打包到主 JavaScript 中。\n\n- Prefetching（预取）\n\n用于连接不同页面的 Link 组件支持 prefetch prop ，在后台自动预取页面资源（包括因代码分割而丢失的代码）。\n\n- Dynamic Components（动态组件）\n\n你可以动态地导入 JavaScript 模块和 React 组件。\n\n- Static Exports（静态导出）\n\n使用next export命令，Next.js 允许你从你的应用程序导出一个完全静态的网站。\n\n- TypeScript Support（支持 TypeScript）\n\nNext.js 是用 TypeScript 编写的，因此，它具有出色的 TypeScript 支持。\n\n### Next.js 学习\n\n#### 1. 新建一个next.js项目\n\n确保在安装next.js项目之前，你的环境有node.js。node,js自带npm，所有安装好node.js，我们的环境就ok了\n\n##### 安装方法： \n\n1. 使用`create-next-app`,\n2. 传统方法，手动安装和设置\n\n##### 先说使用脚手架的方法\n\n我们可以把`create-next-app`当成 `create-next-app`；或者Vue中的`create-vue`；我们直接打开终端运行`npx create-next-app`,脚手架会帮我们新建一个文件夹，并下载项目所需要的包，下载完成后，我们运行`npm run dev`，并在游览器打开`http://localhost:3000`即可看见下面页面：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/UIujXwuP-image.png)\n\n如果跟着`freeCodeCamp`学习的，可以知道我们可以下载一些额外的代码，更加快速的搭建自己的项目，命令为`npx create-next-app --example blog-starter` 其中`blog-starter`为可变的，具体可看这个仓库`https://github.com/vercel/next-learn`\n\n##### 手动创建（0->1）\n\n1. 创建一个文件夹，存放你的`next.js`应用程序\n2. `npm init -y`初始化一个新的node.js项目，`-y`是 `-yes`，告诉`npm`项目使用默认配置，生成一个模板文件`package.json`。\n3. 安装`Next` 和 `React`：`npm install next react react-dom` (如果你还没有喜欢的编辑器，我推荐使用VSCode, 对新人友好，简单，WebStorm也是很好的选择)\n4. 修改脚本(`scripts`) 部分\n\n```javascript\n\"scripts\": {\n  \"dev\": \"next\",\n  \"build\": \"next build\",\n  \"start\": \"next start\"\n}\n// \"dev\": \"next -p 3001\", 这样写，我们的项目启动端口号就是3001\n```\n\n1. 创建一个`pages`文件夹，并添加一个`index.js`文件。\n\n```javascript\nconst Index = () => (\n  <div>\n    <h1>Home page</h1>\n  </div>\n)\n\nexport default Index\n```\n\n1. 使用终端，运行 npm run dev 来启动 Next 开发服务器\n\n#### 2. 验证next.js是SSR的工作方式\n\n**SSR:( 服务器端渲染**`**server side rendered**` **)** ,是一个做门户网站非常好的特性，因为：如果我们使用 Next.js 创建一个网站，网站页面会在服务器上渲染，而服务器会将 HTML 传递给浏览器，具体的优点有三个：\n\n- 客户端不需要实例化 React 来渲染，这使得**网站对你的用户来说更快**。\n- **搜索引擎会对页面进行索引**，而不需要运行客户端的 JavaScript。谷歌开始解决这个问题（客户端渲染），但公开承认是一个较慢的过程（如果你想获得好的排名，你应该尽可能地帮助谷歌）。\n- **你可以有社交媒体元标签**，对添加预览图片，为你在 Facebook、Twitter 上分享的任何页面定制标题和描述都很有用。\n\n验证的方式非常简单：我们右键我们的next.js应用，查看网站源代码，我们可以看到下面这些代码\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <style data-next-hide-fouc=\"true\">\n    body {\n      display: none\n    }\n  </style><noscript data-next-hide-fouc=\"true\">\n    <style>\n      body {\n        display: block\n      }\n    </style>\n  </noscript>\n  <meta charSet=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width\" />\n  <title>Create Next App</title>\n  <meta name=\"description\" content=\"Generated by create next app\" />\n  <link rel=\"icon\" href=\"/favicon.ico\" />\n  <meta name=\"next-head-count\" content=\"5\" /><noscript data-n-css=\"\"></noscript>\n  <script defer=\"\" nomodule=\"\" src=\"/_next/static/chunks/polyfills.js?ts=1668608244862\"></script>\n  <script src=\"/_next/static/chunks/webpack.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/main.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/_app.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/index.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_buildManifest.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_ssgManifest.js?ts=1668608244862\" defer=\"\"></script><noscript\n    id=\"__next_css__DO_NOT_USE__\"></noscript>\n</head>\n\n<body>\n  <div id=\"__next\">\n    <div class=\"Home_container__bCOhY\">\n      <main class=\"Home_main__nLjiQ\">\n        <h1 class=\"Home_title__T09hD\">Welcome to <a href=\"https://nextjs.org\">Next.js!</a></h1>\n        <p class=\"Home_description__41Owk\">Get started by editing\n          <!-- --> <code class=\"Home_code__suPER\">pages/index.tsx</code>\n        </p>\n        <div class=\"Home_grid__GxQ85\"><a href=\"https://nextjs.org/docs\" class=\"Home_card___LpL1\">\n            <h2>Documentation →</h2>\n            <p>Find in-depth information about Next.js features and API.</p>\n          </a><a href=\"https://nextjs.org/learn\" class=\"Home_card___LpL1\">\n            <h2>Learn →</h2>\n            <p>Learn about Next.js in an interactive course with quizzes!</p>\n          </a><a href=\"https://github.com/vercel/next.js/tree/canary/examples\" class=\"Home_card___LpL1\">\n            <h2>Examples →</h2>\n            <p>Discover and deploy boilerplate example Next.js projects.</p>\n          </a><a\n            href=\"https://vercel.com/new?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n            target=\"_blank\" rel=\"noopener noreferrer\" class=\"Home_card___LpL1\">\n            <h2>Deploy →</h2>\n            <p>Instantly deploy your Next.js site to a public URL with Vercel.</p>\n          </a></div>\n      </main>\n      <footer class=\"Home_footer____T7K\"><a\n          href=\"https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n          target=\"_blank\" rel=\"noopener noreferrer\">Powered by\n          <!-- --> <span class=\"Home_logo__27_tb\"><img alt=\"Vercel Logo\" srcSet=\"/vercel.svg 1x, /vercel.svg 2x\"\n              src=\"/vercel.svg\" width=\"72\" height=\"16\" decoding=\"async\" data-nimg=\"1\" loading=\"lazy\"\n              style=\"color:transparent\" /></span>\n        </a></footer>\n    </div>\n  </div>\n  <script src=\"/_next/static/chunks/react-refresh.js?ts=1668608244862\"></script>\n  <script id=\"__NEXT_DATA__\"\n    type=\"application/json\">{\"props\":{\"pageProps\":{}},\"page\":\"/\",\"query\":{},\"buildId\":\"development\",\"nextExport\":true,\"autoExport\":true,\"isFallback\":false,\"scriptLoader\":[]}</script>\n</body>\n\n</html>\n```\n\n可以看到这是一个html网页\n\n#### 3. 安装 React DevTools\n\nNext.js 是基于 React 的，所以我们绝对需要安装一个非常有用的工具（如果你还没有），那就是 React 开发者工具（React Developer Tools\n\n安装成功之后，我们打开`F12`可以看见新增了两个\n\n![img](https://cdn.nlark.com/yuque/0/2022/png/21765913/1668608585453-1c99947b-7c5b-4e52-a100-da13fe8b55fa.png)\n\n它的具体使用可参考[手册](https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#the-app-bundles)的对应部分讲解\n\n#### 4. 给网站添加第二页\n\n非常简单，\n\n1. 在`pages`目录下，新建一个文件，要以`.js .ts .tsx`等结尾，文件名就是路由名称\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/X1I8iTrg-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/kEljTksg-image.png)\n\n- 如果你正在做这一步，你会惊奇的发现，它是热更新的，\n- 如果你喜欢专研，当你查看源代码，你会发现它有类似这种`/_next/static/chunks/pages/new.js?ts=1668609323024`,但是没有主页的`/_next/static/chunks/pages/index.js?ts=1668609366382`这也就验证了，`next.js`的自动代码分包的能力 \uD83D\uDC4D\uD83D\uDC4D\uD83D\uDC4D\n\n#### 5. 链接两个页面\n\n我们可以使用最简单的a标签实现\n\n```html\n<a href=\"/blog\">Blog</a>\n```\n\n但是，我们不能这样做，因为你使用了`next.js`,你可以有更好的方式来实现它\n\n使用 Next 的主要好处之一是，一旦一个页面被加载，由于客户端的渲染，过渡到其他页面的速度非常快。\n\n当我们使用a标签，第一次加载时候，我们得到了所有加载页面的bundles，当我们点击链接，我们又从服务器得到了**所有的JavaScript**，**这样是不合理的**，因为我们已经得到了所有的JavaScript，我们只需要新进来的这个页面的bundle,\n\n**为了解决这个问题**，`next.js`提供了一个组件叫，`Link`,我们现在体验一下，\n\n```javascript\nimport Link from 'next/link' // 先导入它\n```\n\n然后我们把它当做我们的`a`标签使用，像这样 \uD83D\uDC47 \uD83D\uDC47 \n\n```javascript\n<Link href=\"/\">go to home</Link>\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/EuYDDSir-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/WPeG0eeU-image.png)\n\n如果你正在做，你会发现，现在只会再请求一个`new.js`,如果你在这个页面有一个返回按钮，你会发现它不会再次请求任何文件，而且页面的加载速度比以前快了很多，这就是客户端渲染的作用。\n\n#### 6. 路由与动态内容\n\n博客是`next.js`很好的一个使用场景，在博客中有一个非常常见的页面，就是博客文章，文章的样式是固定的，内容是不同的，通过一个动态的URL来判断，不同的URL对应着不同的内容，内容可能取自数据库，也可能是Markdown文档**，Next.js 可以根据一个\\**dynamic URL(动态 URL)\\**来提供动态内容。**具体实现 \uD83D\uDC47 \uD83D\uDC47 \n\n1. 通过使用`[]`语法创建一个动态页面来创建一个动态 URL。\n2. 如何创建？我们添加一个`pages/blog/[id].js`文件。这个文件将处理`/blog/`路径下的所有动态 URL\n3. 方括号内的`[id]`意味着任何动态的东西都将被放在 **路由的查询属性（query property）**的id参数中。\n\n划重点⭐️ ⭐️ ⭐️ \n\n这里可能有帅气的小伙伴会问，什么是路由？？\n\n- 路由(router)是 Next.js 提供的一个库。\n- 我们从 next/router 导入它`import { useRouter } from 'next/router'`\n- 我们有了useRouter，我们就用useRouter来实例化路由对象:`const router = useRouter()`\n- 有了这个路由对象，我们就可以从中提取信息\n- 我们可以通过访问`router.query.id`来获得`[id].js`文件中 URL 的动态部分。\n- 动态部分也可以只是 URL 的一部分，如`post-[id].js`。\n- 让我们`code a demo`\n\n```javascript\n// 创建文件pages/blog/[id].js\nimport { useRouter } from 'next/router'\n// import '../blog/blog'\nexport default () => {\n  const router = useRouter()\n  return (\n    <div className='box'>\n      <h1>Blog Context</h1>\n      <h3>Time: 2022-11-20</h3>\n      <div>\n        <span>Post id: &nbsp;&nbsp;&nbsp;{router.query.id}</span>\n        <br />\n        今天也有认真的学习，认真的生活，嘿嘿！！！<br />\n        \uD83D\uDE06 \uD83D\uDE0A \uD83D\uDE03 \uD83D\uDE0F \uD83D\uDE0D \uD83D\uDE18 \uD83D\uDE1A \uD83D\uDE33 \uD83D\uDE0C \uD83D\uDE06 \uD83D\uDE01 \uD83D\uDE09 \uD83D\uDE1C \uD83D\uDE1D \uD83D\uDE00 \uD83D\uDE17 \uD83D\uDE19 \uD83D\uDE1B<br />\n        \uD83D\uDC99 \uD83D\uDC9C ❤️ \uD83D\uDC9A \uD83D\uDC94 \uD83D\uDC93 \uD83D\uDC97 \uD83D\uDC95 \uD83D\uDC9E \uD83D\uDC98 \uD83D\uDC96 ✨ ⭐️ \uD83C\uDF1F <br />\n        \uD83D\uDE4B \uD83D\uDC70 \uD83D\uDE4E \uD83D\uDE4D \uD83D\uDE47 \uD83D\uDC91 \uD83D\uDC86 \uD83D\uDC87 <br />\n        \uD83D\uDC2D \uD83D\uDC39 \uD83D\uDC30 \uD83D\uDC3A \uD83D\uDC38 \uD83D\uDC2F \uD83D\uDC28 \uD83D\uDC3B \uD83D\uDC37 \uD83D\uDC3D \uD83D\uDC2E<br />\n      </div>\n    </div>\n  )\n}\n```\n\n- 这样我们就可以去`http://localhost:3000/blog/test`路由,其中test可以替换为任意字符，它就是我们接收到的id\n- 那么我们就可以使用这个id作为参数，从一个帖子列表中收集帖子，例如，从一个`JSON`数据库中获取帖子数据，看下面 \uD83D\uDC47 \uD83D\uDC47 \n\n们将在项目根目录下添加一个posts.json文件\n\n```json\n{\n  \"test\": {\n    \"title\": \"test post\",\n    \"content\": \"Hey some post content\"\n  },\n  \"second\": {\n    \"title\": \"second post\",\n    \"content\": \"Hey this is the second post content\"\n  }\n}\n```\n\n现在我们可以导入它，并从id键中查找帖子:\n\n```tsx\nimport { useRouter } from 'next/router'\nimport posts from '../../posts.json'\n\nexport default () => {\n  const router = useRouter()\n\n  const post = posts[router.query.id]\n\n  return (\n    <>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </>\n  )\n}\n```\n\n我们是不是就可以根据id获取数据库（JSON对象）中对应的内容了呢？？\n\n结果是报错了\uD83D\uDC7F\uD83D\uDC7F\uD83D\uDC7F\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/eena7Ygn-image.png)\n\n为什么呢？因为在渲染过程中，当组件被**初始化**时，数据还不在那里。后面会用 **getInitialProps** 向组件提供数据。\n\n虽然解决了这个问题，但它不能实现 SSR，这既损害了用户的加载时间，也损害了 SEO 和社交分享\n\n#### 7. Prefetching\n\n我们使用Link 组件可以用来创建 2 个页面之间的链接，当你使用它时，**Next.js 会透明地为我们处理前端路由**，所以当用户点击一个链接时，前端会负责显示新的页面，而不会像通常网页那样触发新的客户/服务器请求和响应周期。\n\n而且，只要是被`Link`标签包裹的元素出现在视口（viewport）中，Next.js 就会预取(prefetch)它所指向的 URL，只要它是一个本地链接（在你的网站上），就会使应用程序对浏览者来说超级快速。但是这种行为只在生产模式下被触发，这意味着如果你用`npm run dev`运行应用程序，你必须停止它，用`npm run build`编译你的生产包，用`npm run start`运行它。\n\n**注意**： 当页面加载时，任何再折叠上方的链接都会在你的页面触发`load`事件（当页面完全加载时触发，发生在DOMContentLoaded事件之后）时开始预取（prefetch），任何不在视口（viewport）中的其他链接标签将被预取，当用户滚动到它是，它会被预取，预取在高速连接（Wifi 和 3g 以上连接）是自动的，除非浏览器发送 [Save-Data HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data)。\n\n**可以通过设置 prefetch prop 为 false来选择不预取单个 Link 实例**\n\n```javascript\n<Link href=\"/a-link\" prefetch={false}>\n  <a>A link</a>\n</Link>\n```\n\n#### 8. 使用路由器来检测活动链接\n\n在处理链接时，一个非常重要的功能是确定什么是当前的 URL，特别是给活动链接分配一个类别，这样我们就可以使它的样式与其他的不同。我们需要使用的是`next.js`提供的`next/link`\n\n#### 9. 使用 next/router\n\n我们现在已经可以使用`Link`组件声明式的处理`Next.js`中的路由跳转，有时候我们还需要捕获当前路由信息或者编程式的触发路由变化，我们可以使用`useRouter`实例，调用其`push`方法，进行路由的切换，\n\n**注意：**这是客户端的路由，所以方法应该只在面向前端的代码中使用。确保这一点的最简单方法是在useEffect() React hook 中调用，或在componentDidMount()中调用 React 有状态组件\n\n我们最常使用的有俩个API：`push()`和`preFetch()`\n\n- push()允许我们在前端以编程方式触发 URL 变化。:` router.push('/login')`\n- prefetch()允许我们以编程方式预取（prefetch）一个 URL，当我们没有自动处理预取的Link标签时很有用:`router.prefetch('/login')`\n- 也可以使用路由来监听 [路由变更事件](https://nextjs.org/docs#router-events)。\n\n#### 10 .使用 getInitialProps() 向组件提供数据\n\n还记得前面，我们动态生成帖子，初始数据没有的问题吗？？\uD83D\uDE2B\uD83D\uDE2B因为该组件需要一些前期的数据，我们试图从 JSON 文件中获取数据时；我们页面报错了\n\n如何解决报错？又如何使SSR工作于动态路由？\n\n答：我们必须为组件提供 props，使用一个名为 getInitialProps() 的特殊函数，它被附加到组件上，具体实现步骤如下\uD83D\uDC47 \uD83D\uDC47 \n\n- 首先，我们要为该组件命名，例如这样：`export default function Content (){}`\n- 然后，我们为该函数添加属性，`Post.getInitialProps = () => {}`\n- 现在，这个函数可以得到一个对象作为其参数，参数包含有几个属性，其中，就包含我们的`query`对象，也就是我们之前得到帖子ID的对象`Post.getInitialProps = ({query}) => {}`\n- 我们可以从这个函数中返回帖子：\n\n```javascript\nPost.getInitialProps = ({ query }) => {\n  return {\n    post: posts[query.id]\n  }\n}\n```\n\n- 我们这个时候可以删除`useRouter`的导入，我们可以从`getInitialProps`中获得当前路由信息\n\n**关于getInitialProps**\n\n- `getInitialProps`函数将在服务器端执行，但也会在客户端执行\n- `getInitialProps `在它收到的上下文对象(`context object `)中，除了query对象外，还得到了其他的属性\n\n- - `pathname:` URL 的 path 部分\n  - `asPath` - 浏览器中显示的实际路径（包括查询 query）的字符串\n\n如果你做过Node.js编程，你还需要知道。虽然我不知道它在说什么\uD83D\uDE1C\uD83D\uDE1C\uD83D\uDE1C\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/ynJsSe5O-image.png)\n\n#### 11. CSS\n\n选择什么CSS方案是非常重要的，它决定了我们写css代码的方式\n\n我们有很大的自由度，因为我们可以使用任何我们喜欢的库。\n\n但 Next.js 内置了[styled-jsx](https://github.com/vercel/styled-jsx)，因为那是由维护 Next.js 的人建立的一个库。\n\n使用方法非常简单，在JSX的一个片段中插入它，最小实例为\n\n```jsx\n<div className='test'>哈哈哈哈</div>\n<style jsx>{`\n  .test{\n    background: pink;\n  }\n`}</style>\n```\n\n你以为这就完了吗？还有更厉害的\n\n```jsx\nconst Index = props => (\n  <div>\n  <h1>Home page</h1>\n\n  <style jsx>{`\n    h1 {\n      font-size: ${props.size}rem;\n    }\n  `}</style>\n  </div>\n)\n<style jsx global>{`\nbody {\n  margin: 0;\n}\n`}</style>\n```\n\n但是它也有不足的地方，如果你需要引入一个外部的css文件，你必须先安装`@zeit/next-css`（已弃用）\n\n```tsx\n// 先引入依赖\nnpm install @zeit/next-css\n// 然后在项目根目录，创建一个文件next.config.ts，这种写\nimport withCSS from '@zeit/next-css'\nmodule.exports = withCSS()\n```\n\n##### 现在推荐如下使用方式\n\n参考文档：https://nextjs.org/docs/basic-features/built-in-css-support\n\n- 全局的话，需要创建.css文件写入需要的样式，然后导入到pages/_app.js中\n- 从node_modules导入样式\n\n```javascript\n// pages/_app.js\nimport 'bootstrap/dist/css/bootstrap.css'\nimport '@reach/dialog/styles.css'\nexport default function MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}\n```\n\n- 对于组件（页面）级的，添加CSS方式\n\n支持使用 [name].module.css 文件命名约定的 [CSS 模块](https://github.com/css-modules/css-modules)，CSS 模块通过自动创建唯一的类名来本地限定 CSS 的范围。这允许您在不同的文件中使用相同的 CSS 类名，而不必担心冲突。此行为使 CSS 模块成为包含组件级 CSS 的理想方式。CSS 模块文件**可以导入应用程序中的任何位置**.\n\n- 也支持sass\n\n允许您使用 .scss 和 .sass 扩展名导入 Sass。您可以通过 CSS 模块和 .module.scss 扩展名使用组件级 .module.sass。但是在此之前需要安装sass：`npm install --save-dev sass`\n\nSass 支持与上面详述的内置 CSS 支持具有相同的优点和限制。\n\n**注意**：Sass 支持[两种不同的](https://sass-lang.com/documentation/syntax)语法，每种语法都有自己的扩展名。..scss扩展名要求您使用[SCSS](https://sass-lang.com/documentation/syntax#scss)语法，而.sass扩展名要求您使用[缩进语法（“Sass”）](https://sass-lang.com/documentation/syntax#the-indented-syntax).\n\n#### 12. 添加一个封装组件\n\n我们想要使用这个项目，实现我们的想法，我们会发现，会有很多页面的结构都差不多，\n\n我们可以使用组件来复用\n\n#### 13. API Routes\n\n除了创建 页面路由（page routes），也就是将页面作为网页提供给浏览器之外，Next.js 还可以创建 API 路由（API routes）。API 路由也可以像页面一样使用 **动态路由**\n\n#### 14. 在服务器端，或在客户端运行代码\n\n在你的页面组件中，你可以通过检查window属性，判断在服务器端或在客户端执行代码。\n\n```javascript\ntypeof window !== 'undefined'\n// true代表客户端；false代表服务端\n```\n\n### end . conception\n\n#### 简约\n\n参考实例：\n\n- http://www.liuweibo.cn/p/206#heading-11\n- 个人介绍：https://eveningwater.github.io/my-web-projects/website/index.html\n\n#### 链接语雀文档\n\n\n\n#### 博客主页参考文章：\n\n1. https://developer.aliyun.com/article/999730\n2. https://developer.aliyun.com/article/805442#slide-1\n3. [https://raoenhui.github.io/nextjs/2018/08/31/Nextjs%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/#fetching-data-and-component-lifecycle](",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/o8nyzDEv-WX20230411-205204@2x.png",
        "language": null,
        "viewNum": 33,
        "thumbNum": 1,
        "favourNum": 3,
        "commentNum": 1,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-11T12:53:11.000+00:00",
        "updateTime": "2023-04-14T14:56:14.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-14T02:39:50.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "React",
          "笔记"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1645412392449921025",
        "title": "浅谈GPT镜像站点构建",
        "description": null,
        "content": "\n\n## 使用API的好处\n\n现在网上越来越多的镜像网站，其实大多都是通过使用[openAI API](https://platform.openai.com/docs/api-reference/chat/create)的GPT3.5模型，18USD免费额度方式部署，通过API的方式访问速度会更快，回复也更快，字数限制也是可控的，比访问官网更加稳定。\n\n其实很多镜像网站使用的也是在github上面开源的，start数较多的项目，像[https://chatbot.theb.ai/](https://chatbot.theb.ai/) 等镜像站点也都是使用的 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web) 开源项目。鱼皮专门分享了一期如何在[github中找项目](https://www.bilibili.com/video/BV1Ki4y1T7Cu/?spm_id_from=333.337.search-card.all.click)，可以帮助我们更加高效找到有用项目\n\n## 本地镜像部署\n\n目前市面上有很多人部署了镜像站点，但是本身是有一定免费额度的，况且GPT4模型可是20刀每月，应该没有这么多慈善家共享出来吧，那么选择部署3.5模型，知识库在2021年也够个人使用了。\n\n项目地址直接用 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，文档写的很详细，按着步骤走基本就能正常跑项目，注意次项目是前后端分离项目，也就是你需要启用前端和后端两个服务，进入service文件夹就可以启动后端\n\n重点就是配置env环境变量，只要有了GPT账号就变得简单了：\n\n```js\n// OpenAI API Key - https://platform.openai.com/overview ，请使用自己的KEY\nOPENAI_API_KEY=sk-rrcD2Szetumo22Ehc\n\n// change this to an `accessToken` extracted from the ChatGPT site's `https://chat.openai.com/api/auth/session` response\nOPENAI_ACCESS_TOKEN=\n\n// OpenAI API Base URL - https://api.openai.com\nOPENAI_API_BASE_URL=\n\n// OpenAI API Model - https://platform.openai.com/docs/models\nOPENAI_API_MODEL=\n\n// set `true` to disable OpenAI API debug log\nOPENAI_API_DISABLE_DEBUG=\n\n// Reverse Proxy\nAPI_REVERSE_PROXY=https://bypass.churchless.tech/api/conversation\n\n// timeout\nTIMEOUT_MS=100000\n\n// Rate Limit\nMAX_REQUEST_PER_HOUR=\n\n// Secret key\nAUTH_SECRET_KEY=\n\n// Socks Proxy Host\nSOCKS_PROXY_HOST=\n\n// Socks Proxy Port\nSOCKS_PROXY_PORT=\n\n// Socks Proxy Username\nSOCKS_PROXY_USERNAME=\n\n// Socks Proxy Password\nSOCKS_PROXY_PASSWORD=\n\n// HTTPS PROXY | 我使用的Clash，代理端口默认是7890，所以要看你本地代理端口\nHTTPS_PROXY=http://127.0.0.1:7890\n```\n\n如果正确使用了KEY，那么本地就可以访问了。\n\n次项目最重要的应该就是后端接口这一部分，因为前端可以直接在云服务器上部署，但是后端在国内基本是直接部署不了的，需要你像本地一样，使用代理才可以访问。\n\n亦或者使用国外服务器部署，我ping过一些镜像网站，基本公网IP都是在国外.\n\n\n![1.png](https://pic.code-nav.cn/post_picture/1621094259987947521/eex0Aq9f-1.png)\n\n![2.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KD6mroZR-2.png)\n\n所以我就没有选择部署公网了，但是为了使用方便我把前端部署出来了，只需要填写API后端地址就可以在线访问啦！！！\n\n\n![3.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KyIAGJM6-3.png)\n\n## 本地持久化开启服务\n\n当有了前端，没有后端是访问不了的，所以我用了最朴素的方式，就是当我每次打开电脑后就自动开启service服务，那么我就随时可以在本地使用镜像API了，偶尔我还能蹭到别人的后端，因为很多用户用了开源项目就没有修改接口的。\n\n当我们本地可以正常使用的时候，我们只需要做到开机就自动启动服务就好了，我选择了使用`pm2`进行项目守护进程。\n\n在service下进行如下命令：\n\n```bash\n# 全局安装\nnpm install pm2 -g\n# 不用后卸载\nnpm uninstall pm2 -g\n# 如果是linux就可以直接使用\npm2 start npm --name \"my-app-name\" -- start\n# 显然我使用的是windows，所以需要使用下面服务\nnpm install -g pm2-windows-service\n\n# 后端项目进行打包\nnpm run build\n# 后端根目录新建startscript.js ，新增如下内容\nconst cmd = require('node-cmd')\ncmd.run('npm run  prod')\n# 安装node-cmd依赖\nnpm install node-cmd --save\n\n# 安装window服务进程\npm2-service-install -n\n# 使用pm2守护进程\npm2 start startscript.js --name \"my-app-name\" \n```\n\n![4.png](https://pic.code-nav.cn/post_picture/1621094259987947521/k0hRvSAp-4.png)\n\n成功后就可以本地访问了，并且可以通过服务去开启或者关闭进程，不需要每次打开在本地跑项目了！！！\n\n有一点不明白，就是我如果本地直接运行后端就需要开启VPN代理才能访问接口，但是使用了持久化后我关闭了代理，也能够访问~~",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1621094259987947521/bRK7rdha-3.png",
        "language": null,
        "viewNum": 83,
        "thumbNum": 6,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1621094259987947521",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-10T13:04:19.000+00:00",
        "updateTime": "2023-04-15T05:47:07.000+00:00",
        "user": {
          "id": "1621094259987947521",
          "planetCode": "9263",
          "userName": "帅气的木木",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1621094259987947521/Zz4fuDXN-QQ图片20221118113213.jpg",
          "gender": 1,
          "userProfile": "前端CV工程师",
          "userRole": "vip",
          "interests": [
            "资源"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 999999999,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 5,
          "coin": 20,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-19T23:00:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-02T10:32:44.000+00:00",
          "updateTime": "2023-03-23T07:40:52.000+00:00"
        },
        "tags": [
          "文章",
          "ChatGPT",
          "前端"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1644305295544995842",
        "title": "ThreadLocal：听说你很熟悉我？",
        "description": "对于 ThreadLocal 常见知识点的源码分析",
        "content": "> 基于 JDK1.8\n# ThreadLocal\n`ThreadLocal` 可以用于创建线程本地变量，每个线程使用 `ThreadLocal` 都会拥有自己对该变量的副本，即每个线程都可以独立地改变其副本的值，而不会影响其他线程的副本。\n\n## 数据结构\n`ThreadLocal` 其实就是由内部实现的 `ThreadLocalMap` 组成的，`ThreadLocalMap`  是以 `ThreadLocal` 的**弱引用**作为 `key` ，`value` 为代码中放入的值，每个线程在往 `ThreadLocal` 里放值的时候，都会往自己的 `ThreadLocalMap` 里存，读也是以 `ThreadLocal` 作为引用，在自己的 `map` 里找对应的 `key` ，从而实现了线程隔离。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d20c633ea342d8a052d90ce29cc0eb~tplv-k3u1fbpfcp-watermark.image?)\n\n## ThreadLocalMap\n### 数据结构\nThreadLocalMap 底层就是由 Entry 数组构成\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n<p align=center><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9dcea993fd7456bb837f71f9ed5739e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"  /></p>\n\n### ThreadLocalMap.set() 原理解析\n> 源码\n````java\nprivate void set(ThreadLocal<?> key, Object value) {\n    // Entry数组\n    Entry[] tab = table;\n    int len = tab.length;\n    // 获取当前key 的索引位置\n    int i = key.threadLocalHashCode & (len-1);\n    // 以当前 key 对应的 Entry 为起点，遍历 Entry 数组\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        // 当前 Entry 的 key 等于插入值的 key\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        // 当前 Entry 的 key 为 null\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    // 插入元素\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    // 进行启发式清理工作，清除 key 为 null 的数据\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n````\n- 将 `key` 的 `HashCode` 与 `Entry` 数组的长度减一相与获取 `key` 对应的索引位置\n- 根据索引位置获取 `key` 对应的 `Entry`，以该 `Entry` 为起点遍历 `Entry` 数组\n    - 如果当前 `Entry` 为 `null` ，那么直接创建一个新的 `Entry` 插入\n    - 如果当前的 `Entry` 不为 `null`\n        - 如果当前 `Entry` 的 `key` 等于插入值的 `key` ，那么就会替换当前 `Entry` 的 `value` ，然后结束方法。\n        - 如果当前 `Entry` 的 `key` 为 `null` ，说明 `Entry` 是过期数据，执行 `replaceStaleEntry` 方法来替换过期的数据，然后结束方法。\n        - 如果以上两种情况都不符合那么就会获取到下一个 `Entry` 继续判断\n\n- 增加 `Entry` 数组的长度\n- 调用 `cleanSomeSlots` 方法进行启发式清理工作，清理数组中  `Entry` 的 key 为 `null` 的数据，如果 `cleanSomeSlots` 方法未清理任何数据，且当前数组的长度超过了阈值，那么就会调用 `rehash` 方法进行扩容\n\n### ThreadLocalMap.replaceStaleEntry() 原理解析\n> 源码\n\n```java\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // 待插入元素对应的索引位置\n    int slotToExpunge = staleSlot;\n    // 从待插入元素对应的索引位置开始向前迭代，\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // 从待插入元素的索引位置 staleSlot 开始向后迭代\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 相同\n        if (k == key) {\n            e.value = value;\n            // 互换位置\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // 清除过期 Entry\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // key 为null\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // 未找到 key相同的Entry\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // 清理过期数据\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n- 从插入值的索引位置 `staleSlot` 开始向前迭代，找到其他过期数据，然后更新过期数据的起始位置 `slotToExpunge`，直到 `Entry` 为 `null`。\n- 从待插入元素的索引位置 `staleSlot` 开始向后迭代\n    - 如果找到了 `key` 相同的 `Entry`  ，则将当前 `Entry` 的值设置为我们插入的值，然后将当前 `Entry` 的位置与待插入元素对应的 `Entry` 位置互换，接着就根据第 1 步获取到的 `slotToExpunge` 开始过期 `Entry` 的处理，最后退出方法。\n    - 如果当前 `Entry` 的 `key` 为 `null`，且过期数据的起始位置 `slotToExpunge` 位于 `staleSlot` ，那么更新 `slotToExpunge` 为当前 `Entry` 的索引位置。\n- 如果在循环中找不到 `key` 相同的 `Entry`，就会创建新的Entry替 换 `table[stableSlot]` 的位置\n- 最后进行过期数据的清理\n\n### ThreadLocalMap.expungeStaleEntry() 原理解析\n> `int staleSlot`：空 slot 的起始位置\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // staleSlot 即为过期 Entry 的起始位置\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    Entry e;\n    int i;\n    // 从起始位置开始向后遍历\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 为null\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        // key 不为 null\n        } else {\n            // 判断位置是否偏离\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                // 位置偏离重新计算位置\n                tab[i] = null;\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n- 将起始位置的 `Entry` 设置为 `null` ，并减小数组中元素的个数。\n- 从起始位置开始向后遍历 `Entry` 数组：\n    - 如果遇到 `key` 为 `null` 的 `Entry` ，那么就把当前的 `Entry` 设置为 `null` ，并且减小数组中元素的个数，然后继续往后探测。\n    - 如果碰到 `key` 不为空的 `Entry` （记作 e ），那么就会重新计算当前 `key` 对应的索引位置（记作 h ），如果与原先的索引位置（也就是当前的 i 值）发生偏离，那么就会将 `i` 对应的 `Entry` 设置为 `null` ，然后重新计算 `e` 的位置。\n    - 如果碰到空的 `slot`  则结束清理，返回空 `slot` 的位置。\n\n### ThreadLocalMap.cleanSomeSlots() 原理解析\n> `int i`：当前 Entry 的位置 <br>\n> `int n`：在插入元素时调用，这个参数代表元素的个数；在 replaceStaleEntry 中调用，这个参数代表数组的长度 。\n``` java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n- 从当前 Entry 开始向后遍历，遍历 log2(n)  个元素\n- 遇到 key 为null 的Entry 则调用 expungeStaleEntry 进行清理\n\n### ThreadLocalMap 扩容机制\n在set方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值就会执行rehash()\n\n#### rehash 方法\n``` java\nprivate void rehash() {\n    expungeStaleEntries();\n\n    // 数组中的元素个数是否大于 threshold * 3/4\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n```\n- 首先会调用 `expungeStaleEntries` 方法对 `Entry` 数组进行过期数据的清理\n- 然后判断当前数组中的元素个数是否大于 threshold * 3/4 ，如果大于那么就会调用 resize 方法进行扩容\n\n#### resize 方法\n\n``` java\nprivate void resize() {\n    Entry[] oldTab = table;\n    // 旧容量\n    int oldLen = oldTab.length;\n    // 新容量\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (Entry e : oldTab) {\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n                // 重新计算hash\n                int h = k.threadLocalHashCode & (newLen - 1);\n                // hash 冲突则往后查找\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n    // 重新计算扩容阈值\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n```\n- 扩容后的 `Entry` 数组的长度变为旧容量的 `2` 倍\n- 然后去遍历旧的 `Entry` 数组，重新计算 `hash` 位置，然后放到新的 `Entry` 数组中，如果出现 `hash` 冲突则往后寻找最近的 `Entry` 为 `null` 的槽位，遍历完成之后，旧数组中所有的 `Entry` 数据都已经放入到新的 `Entry` 数组中。最后重新计算数组的扩容阈值。\n\n### ThreadLocalMap.getEntry() 原理解析\n> `ThreadLocal<?> key` ：当前key\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    // 获取索引\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    // 命中则直接返回\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n根据 `key` 的 `hash` 获取对应的 `Entry`，如果当前 `Entry` 的 `key` 等于查找的 `key` 那就返回当前 `Entry`，否则就调用 `getEntryAfterMiss` 方法。\n\n### ThreadLocalMap.getEntryAfterMiss() 原理解析\n当 `key` 在其直接哈希槽中找不到时使用\n> `ThreadLocal<?> key` : ThreadLocal 对象 <br>\n> `int i` : ThreadLocal 对应的 hash 值 <br>\n> `Entry e` : ThreadLocal 对应的 Entry\n``` java\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n- 如果当前 `key` 对应的 `Entry` 不为空\n    - 判断当前 `Entry` 的 `key` 是否等于获取的 `key` ，是的话那么就返回当前的 `Entry`。\n    - 如果当前 `Entry` 的 `key` 为 `null` 那么就会调用 `expungeStaleEntry` 方法来清理，接着继续往后迭代。\n- 如果当前 `key` 对应的 `Entry` 为空就直接返回 `null`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1621700430587248641/935IjQjR-v2-fe127aac97845744e7b2124ffe16df6d_r.jpg",
        "language": null,
        "viewNum": 62,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1621700430587248641",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-07T11:45:06.000+00:00",
        "updateTime": "2023-04-15T14:17:41.000+00:00",
        "user": {
          "id": "1621700430587248641",
          "planetCode": "17433",
          "userName": "枫",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/n7ib3uuEjhfGIvSSR9AwHFKet7RmG0HOFRFS23ibqicX3grkZc7lafFxtb4YxXUuVVKy92omwDabWTZyQiaFJXN3SA/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:01:54.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-04T02:41:27.000+00:00",
          "updateTime": "2023-04-14T05:01:03.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "40",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "4"
  },
  "message": "ok"
}